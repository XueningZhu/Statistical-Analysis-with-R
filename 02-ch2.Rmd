# 第2章：R语言中的数据管理与预处理 {#ch2}

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = F, warning = F, cache = T)
```

```{r}
rm(list = ls())#清空环境
movie <- read.csv("./data/top250.csv",fileEncoding = "gbk")#读取数据
head(movie)#电影数据示例
```

## 基本数据类型

###  数值型
```{r}
class(movie$score)#查看数据类型
#自己为变量附一个数值
a=2;class(a)
exp(1000)  # 正无穷
-10 / 0  # 负无穷
exp(1000) / exp(990)  # NaN类型
exp(10)
```

### 字符

```{r}
#字符的定义
a = "2"
class(a)
# 判断电影数据集中，变量“类型(type)","电影名称(name)"是不是字符型变量
class(movie$name)
class(movie$type)
```


### 逻辑型
```{r}
# 读入数据时设置把字符数据保留，不转换为factor
movie = read.csv("./data/top250.csv", header = T, stringsAsFactors = F, fileEncoding = "gbk")
movie$type[movie$name == "霸王别姬"] == "爱情" 

# 想在数据集中挑选大于9分的喜剧电影名称（name）？
movie$name[movie$type == "喜剧" & movie$score > 9]

# 逻辑语句加减
(1 == 2) + (3 < 4)
```

### 因子型数据
```{r}
## 1.什么是因子型数据 ##
(genders = factor(c("男", "女", "女", "男", "男")))#生成因子型变量

(class = factor(c("Poor", "Improved", "Excellent"), ordered = T))#设置因子水平高低

## 2.改变因子型数据各水平的编码顺序 ##
(class = factor(c("Poor", "Improved", "Excellent"), ordered = T,
              levels = c("Poor", "Improved", "Excellent")))

## 3.因子型和字符型数据互相转换 ##
# 输入原始字符变量
all = c("男", "女", "女", "男", "男")
# 将字符型变量变成因子型
gender = as.factor(all)
# 变换后的数据类型
is.factor(gender)
class(gender)#判断gender的数据类型
```

## 数据结构

```{r}
rm(list = ls())#清理工作空间
movie = read.csv("./data/top250.csv",fileEncoding = "gbk",stringsAsFactors = FALSE)#导入数据
```

### 向量
```{r}
###1.基本操作###
## (1)向量创建##
c(1, 1, 1, 2, 3, 3, 1, 2, 4, 1, 2, 4, 4, 2, 3, 4, 1, 2, 3, 4)
c("a", "b", "c", "d")
# seq(起始值, 终止值, 步长)
seq(0, 10, by = 2)#生产0-10之间以2为间隔的等差数列
1:10#生成1—10的连续数列

##(2)向量索引##
x<-c(1, 1, 1, 2, 3, 3)#生成向量
x[5]# 引用x向量中的第5个元素
which(x == 3)#查看x向量中3所在的位置
which.max(x)#查看x向量中最大值所在的位置
which.min(x)#查看x向量中最小值所在的位置

##(3)集合运算##
intersect(c(1, 2, 3, 3, 12, 4, 123, 12), c(1, 2, 3))#求交集
union(c("狗熊会", "聚数据英才"), c("狗熊会", "助产业振兴"))#求并集
setdiff(10:2, 5:3)#求差集
### 2.常见向量类型及操作 ###
## (1)数值型向量 ##
x<-c(10,6,4,7,8)#创建数值向量
min(x)#求最小值
max(x)#求最大值
range(x)#求范围
# match函数
x <- c(1, 1, 1, 2, 3, 3, 1, 2, 4, 1, 2, 4, 4, 2, 3, 4, 1, 2, 3, 4)
(y <- letters[x]) # letters是一个内置字符串，里面储存26个字母字符
match(y, letters[1:4])

x <- c("a", "c", "g", "h")
letters
match(x, letters)

# cut函数
(Age = c(72,21,39,74,62,76,64,43,94,44,87,43,42,35,39,46,45,33,24,38))#生成向量
# 将年龄数据离散化  
label = c('青年', '中年', '老年')  #设置标签
(ages = cut(Age, breaks = c(20, 35, 50, 100), labels = label))#划分区间

# sort和order函数
(x = c(1,5,4,6,7))#生成向量
sort(x)
order(x)
x[order(x)]

## (2)字符串向量 ##
# nchar用来提取字符串的长度
nchar("欢迎关注狗熊会")
# 看看数据集中的电影名字的长度分别是多少
nchar(movie$name)
# 中英文的字符长度计算方法有不同
nchar("Welcome to follow the CluBear")
# substr提取子字符串
substr("欢迎关注狗熊会", 1, 4)
substr("一懒众衫小", 3, 5)
# paste基本玩法
paste(c("双11", "是个", "什么节日"), collapse = "")
paste("A", 1:4)
# paste花式玩法
paste(1:4, collapse = "")
paste(1:4, sep="")
paste("A", 1:4, sep="_")


txt = c("狗熊会", "CluBear", "双11", "生日")
# 返回含有关键字的字符位置
grep("Bear", txt)
gsub("生日", "happy birthday", txt)
# grep返回movie的director中包含“青春”的行号2，movie[2, ]即提取出movie数据集的第2行
(index <- grep("陈凯歌", movie$director))
(cmovie <- movie[index, ])


salary = c("22万", "30万", "50万", "120万", "11万")
(salary0 = gsub("万", "0000", salary))
mean(as.numeric(salary0))
median(as.numeric(salary0))  # 结果是科学计数法的形式
```


### 矩阵
```{r}
### 1.创建与引用 ###
##(1)创建##
# 生成全部是0的矩阵
(zero = matrix(1:9, nrow = 3, ncol = 3))
# 生成一个对角全是1的矩阵,直接在diag中输入对角线向量即可
(dig14 = diag(rep(1, 4)))

##(2)创建##
# 从已有数据转化成矩阵
(M = matrix(1:12, nrow = 3, ncol = 4))
# 生成指定对角元素的对角矩阵
(N = diag(1:4))

### 2.基本的矩阵操作 ###
## 矩阵概览 ##
# 查看矩阵的维度
dim(M) 
# 提取矩阵的行数
nrow(M) 
# 提取矩阵的列数
ncol(M)
##  [1] 4
# 引用元素
M[1, 2]
M[1:2, 2:3]
# 给行列命名
colnames(M) = paste("x_", 1:4)
rownames(M) = 1:3; M
# 同样的命令可调用行列名
colnames(M)
rownames(M)
# 将多个矩阵合并
(A = matrix(1:9, nrow = 3, ncol = 3, byrow = T))
(B = diag(11:13))
rbind(A, B) 
cbind(A, B) 

### 3.矩阵的数学操作 ###
A + B #矩阵的加法
A - B #矩阵的减法
A * B #矩阵各元素对应相乘
A %*% B #矩阵的乘法
solve(B) #矩阵B的逆
eigen(B) #矩阵B的特征值


```

### 数组
```{r}
##1.创建及引用##
# 创建数组
(result <- array(1:18,dim=c(3,3,2),dimnames = list(c("r1","r2","r3"),c("c1","c2","c3"),c("h1","h2"))))
result[1,2,2]#获取单个元素
result[1,,] #获取第一维度的数据

##2. 操作数组元素##
matrix1<-result[,,1]#获取数组中第1水平的矩阵
matrix2<-result[,,2]#获取数组中第2水平的矩阵
(add<-matrix1+matrix2)#矩阵相加
```

### 数据框
```{r}
### 1.创建数据框 ###
# 读入一个txt,csv等格式数据,即自成一个数据框
movie <- read.csv("./data/top250.csv", fileEncoding = "gbk", stringsAsFactors = F)
class(movie)
# 自己创建
director <- c("陈凯歌", "宫崎骏", "李廷香","詹姆斯·卡梅隆", "刘镇伟", "周星驰", "李安", "姜文", "张艺谋", "吴宇森","岩井俊二", "王家卫", "陈可辛"  )
birthyear <- c(1952,1941,1964,1954,1952,1962,1954,1963,1950,1946,1963,1958,1962)
gender <- c("男", "男", "女", "男", "男", "男", "男", "男", "男", "男", "男", "男", "男")
directors <- data.frame(director, birthyear, gender); head(directors)

### 2.变形--长宽表互换 ###
# install.packages(reshape)
library(reshape)
# install.packages(reshape2)
library(reshape2)
## (1) 宽表变长表 ##
mWide = data.frame(Name = c("A", "B"), Type = c("喜剧", "动作"),
                   GF2018 = c(6.5, 8.0), GF2019 = c(7.0, 7.5), GF2020 = c(8.1, 7.3))
                   # 由于构造数据框时列名不可以为纯数字，在数字前添加GF
# 将列名中的GF去掉
colnames(mWide)[3:5] = gsub("GF", "", colnames(mWide)[3:5])
mWide #查看原表
(mLong = melt(mWide, id.vars = c("Name", "Type"), variable_name = "Year")) 

## (2) 长表变宽表 ##
# 将列Year从字符型变成数值型
#mLong$Year = as.numeric(mLong$Year)

# 长表变宽表
dcast(mLong, Name + Type ~ Year)
### 3.R中的数据透视表-神奇的ddply ###
# install.packages(plyr)
library(dplyr)
# 根据电影类型进行分组，查看不同类型电影评分的平均水平
popular_type_grouped=group_by(movie,type)#根据电影类型进行分组
popular_type1=summarise(popular_type_grouped,
                        mean_score=mean(score),#计算不同类型的平均评分
                        max_score=max(score))#计算不同类型的最高评分
head(popular_type1)
#利用管道函数%>%省去中间变量命名
popular_type2 = movie%>%group_by(type)%>%
  summarise(mean_score=mean(score),#计算不同类型的平均评分
            max_score=max(score))#计算不同类型的最高评分
head(popular_type2)
```

## 数据的读入


```{r}
rm(list = ls())#清理工作空间
movie = read.csv("./data/top250.csv",fileEncoding = "gbk",stringsAsFactors = FALSE)#导入数据
```

### 使用键盘输入数据
```{r}
scores <- c(61,66,84,80,100)
#scores <- data.frame() #建立一个空数据框
#scores <-edit(scores)  #触发R内置编辑器
# 输入数据集
mydatatxt<-"name gender age
张三 M 20
李四 F 23
"
(mydata<-read.table(header = TRUE,text = mydatatxt)) # 读取数据集
```

### 从带分隔符的文本文件导入数据
```{r}
### 1. read.rable() ###
#从txt中读入,分隔符为"\t"
tes = read.table("./data/top250.txt", header = TRUE, sep = "\t",fileEncoding = "GBK"); head(tes)

### 2. read.csv() ###
#专用函数read.csv
movie_csv = read.csv("./data/top250.csv",fileEncoding = "GBK"); head(movie_csv)

```

### 导入Excel数据
```{r}
library("readxl") # 加载包
# 其中col_names参数仍然是为了设定是否把第一行当做变量名
movie_excel = data.frame(read_excel("./data/top250.xlsx", col_names = TRUE));head(movie_excel)
```


```{r,include=FALSE}
options(encoding = "gbk")
```

### 逐行读入数据
```{r}
#建立与文件的连接
con<-file("./data/top250.csv")
#逐行读入所有数据
line_all<-readLines(con)
#读取前10行数据
line_10<-readLines(con,n=10)
line_10
close(con)#关闭连接
split_line=strsplit(line_all,",")#分隔符为”,”
head(split_line,3)
```

## 数据集管理及预处理

```{r}
rm(list = ls())#清理工作空间
movie = read.csv("./data/top250.csv",fileEncoding = "gbk",stringsAsFactors = FALSE)#导入数据
```

### 了解数据概况
```{r}
str(movie)
summary(movie)
```



### 变量类型转换
#### 1.基本数据类型之间的转换
```{r}
a="1"#将1赋值给a
is.numeric(a)#判断a是否是数值型数据
a<-as.numeric(a)#将a转换为数值型数据
is.numeric(a)#再次判断a是否是数值型数据
```
#### 2.不同结构化数据类型间的转换
```{r}
tbl <- table(movie$nation)#统计不同国家的频次
class(tbl)#查看数据格式
tbl <- as.data.frame(tbl)#转化为数据框
class(tbl)
```

#### 3.日期值转换
```{r}
###(1)将字符转换成Date日期格式###
# 函数head用来查看数据前6个元素，函数class用来查看对象数据类型
head(movie$showtime)
class(movie$showtime)
movie$showtime = as.Date(movie$showtime)
head(movie$showtime)
class(movie$showtime)
as.Date('1/15/2020', format = '%m/%d/%Y') #对日/月/年类型字符进行日期转换
###(2)将字符转换成POSIXct/POSIXlt时间格式###
as.POSIXct(1472562988, origin = "1960-01-01")#日期值转换，以"1960-01-01"为起点
```

### 时间型数据的操作
#### 1.特征提取
```{r}
library(lubridate)#加载lubridate包
t = "2020-11-20 01:30:29"
year(t)#提取年份
month(t)#提取月份
mday(t)#提取日期是一个月中的第几天
wday(t)#提取日期是一周中的第几天
hour(t)#取出日期中的小时数
minute(t)#取出日期中的分钟数
second(t)#取出日期中的秒
```

#### 2.插值运算
```{r}
# 求任意两个日期距离的天数
begin = as.Date("2016-03-04")
end = as.Date("2016-05-08")
(during = end - begin)
# 求任意两个日期距离的周数和小时数
difftime(end, begin, units = "weeks")
difftime(end, begin, units = "hours")
```

#### 3.排序
```{r}
# 单独对时间进行排序
head(sort(movie$showtime))
# 对数据表格中的数据按照时间顺序排列,这里只选取前6行，对电影名称、上映日期做展示
head(movie[order(movie$showtime), c("name", "showtime")])

```

### 数据集合并
```{r}
director <- c("陈凯歌", "宫崎骏", "李廷香","詹姆斯·卡梅隆", "刘镇伟", "周星驰", "李安", "姜文", "张艺谋", "吴宇森","岩井俊二", "王家卫", "陈可辛"  )
birthyear <- c(1952,1941,1964,1954,1952,1962,1954,1963,1950,1946,1963,1958,1962)
gender <- c("男", "男", "女", "男", "男", "男", "男", "男", "男", "男", "男", "男", "男")
directors <- data.frame(director, birthyear, gender); 
# merge实现的效果是：将movie和directors按照列director匹配并合并起来
(movie.star = merge(movie[1:10, ], directors,by = "director")) 


```
### 数据缺失、异常

```{r}
###(1)删除法###
movie_new=na.omit(movie)#保留完整观测的行

###(2)插补法###
#将均值替换电影时长缺失值
movie[is.na(movie$duration), ]$duration<-mean(movie$duration, na.rm = T)
movie[which(movie$score<0), ]$score<-NA#将异常值赋值为NA
movie[is.na(movie$score), ]$score<-mean(movie$score, na.rm = T)#赋值均值


```

## 习题答案

### 题目 2.1 {-}

如何理解R语言中的“向量化”操作？请举一个例子说明。

对于一个向量$x$，“向量化”操作指命令可以直接对向量的每个元素进行操作，不需要使用循环实现计算。比如命令语句$x$+2或者$x^3$，向量$x$中的每个元素都加2或每个元素都变成三次幂。

### 题目 2.2 {-}

请描述R语言中矩阵与数据框之间的两个不同点。

a.数据框实际上是由多个长度相同的向量组成，而矩阵实际上是一个二维向量。

b.数据框所包含的向量可以是不同数据类型的，而矩阵仅能包含一种数据类型。

### 题目 2.3 {-}

对矩阵的操作：

1.在R中生成生成下面的矩阵A。

$$A=\left(\begin{array}{lll}
1 & 2 & 3 \\
4 & 2 & 1 \\
2 & 3 & 0
\end{array}\right)$$

```{r}
#构造矩阵
(A=matrix(c(1,4,2,2,2,3,3,1,0),nrow=3))
```

2.计算矩阵A的转置矩阵B和逆矩阵C。

```{r}
(B=t(A))#求转置矩阵
(C=solve(A))#求逆矩阵
```

3.求矩阵A和矩阵C的乘积。

```{r}
A%*%C#矩阵乘积
```
### 题目 2.4（实训题目）{-}

实训题目：使用电视剧网播量数据集，该数据集收集了4266条电视剧的信息。请完成以下任务。

a.	获取数据集，查看数据概况。

```{r}
tv<-read.csv("./data/电视剧播量.csv",fileEncoding="gbk",stringsAsFactors = F)#读取数据
head(tv)#查看数据前几行

```

b.	删除数据集中剧名缺失的值。

```{r}
tv<-tv[-which(tv$剧名 == "null"),]#删除缺失数据
```

c. 不考虑缺失数据影响，计算电视剧的平均得分。

```{r}
#将缺失数据处理成NA
tv[which(tv$得分=="null"),]$得分=NA
tv[which(tv$得分=="."),]$得分=NA
#转换数据格式
tv$得分<-as.numeric(tv$得分)
#计算平均得分
mean(tv$得分,na.rm = T)

```

### 题目 2.5 （实训题目）{-}

实训题目：使用手机游戏数据集，该数据集收集了1141条手机游戏信息及评分。请完成以下任务。

a.	获取数据集，查看数据概况。
```{r}
game<-read.csv("./data/安卓手机游戏.csv",fileEncoding = "gbk",stringsAsFactors = F)#读取数据
summary(game)#查看数据概况
```

b.	提取热度中的数值部分，计算各游戏类型的热度均值，找出平均热度最高的游戏类型。
```{r,eval=FALSE}
#加载包
library(stringr)
library(dplyr)
```
```{r,include=FALSE}
#加载包
library(stringr)
library(dplyr)
```

```{r}
#转换数据格式
game$hot<-as.numeric(str_extract(game$热度,"\\d+"))
#计算热度均值
hot_aver<-game%>%
  group_by(类别)%>%
  summarise(meanhot=mean(hot,na.rm = T))#平均热度
#找出平均热度最高的游戏类型
(hot_aver=hot_aver[order(hot_aver$meanhot, decreasing = T), ])

```
平均热度最高的游戏类别为体育运动。

c.	计算各游戏类型的平均评分，最高评分，最低评分，评分标准差，并作简要分析。
```{r,warning=FALSE}
grade_aver<-game%>%
  group_by(类别)%>%
  summarise(meangrade=mean(评分,na.rm = T),#平均评分
            maxgrade=max(评分,na.rm = T),#最高评分
            mingrade=min(评分,na.rm = T),#最低评分
            sdgrade=sd(评分,na.rm = T))#评分标准差
(grade_aver=grade_aver[order(grade_aver$meangrade, decreasing = T), ])#按照平均得分排序

```

分析：虽然平均热度最高的游戏类别为体育运动，但平均评分最高的游戏类别为角色扮演，同时角色扮演的评分波动较大。
